
/*******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for the Empty Application Example
*              for ModusToolbox.
*
* Related Document: See README.md
*
* From Sender 1 =  100
* From Sender 1 =  100
* From Sender 1 =  100
* From Sender 1 =  100
* From Sender 2 =  200
* From Sender 1 =  100
* From Sender 1 =  100
*******************************************************************************/
#include "cybsp.h"
#include "cyhal.h"
#include "cy_retarget_io.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

/******************************************************************************
* Macros
*******************************************************************************/


/*******************************************************************************
* Global Variables
*******************************************************************************/
QueueHandle_t xQueue;  // Declare the queue handle

/*******************************************************************************
* Function Prototypes
*******************************************************************************/
void vPrintStringAndNumber(const char *pcString, volatile uint32_t ul);
void vPrintString(const char *pcString);
static void vSenderTask(void *pvParameters);
static void vReceiverTask(void *pvParameters);

/* Define an enumerated type used to identify the source of the data. */
typedef enum {
    eSender1,
    eSender2
} DataSource_t;

/* Define the structure type that will be passed on the queue. */
typedef struct {
    uint8_t ucValue;
    DataSource_t eDataSource;
} Data_t;

/* Declare two variables of type Data_t that will be passed on the queue. */
static const Data_t xStructsToSend[2] = {
    {100, eSender1}, /* Used by Sender1. */
    {200, eSender2}  /* Used by Sender2. */
};


/*******************************************************************************
* Function Definitions
*******************************************************************************/

// Function to print a string
void vPrintString(const char *pcString) {
    printf("%s", pcString);  // Print the string to UART (Retarget IO)
}

// Function to print a string and a number
void vPrintStringAndNumber(const char *pcString, volatile uint32_t ul) {
    printf("%s", pcString);  // Print the string to UART (Retarget IO)
    printf(" %ld\n", ul);    // Print the number to UART (Retarget IO)
}

// Sender task to send data to the queue
static void vSenderTask(void *pvParameters) {
    BaseType_t xStatus;
    const TickType_t xTicksToWait = pdMS_TO_TICKS(100);

    for(;;) {
        xStatus = xQueueSendToBack(xQueue, pvParameters, xTicksToWait);
        if (xStatus != pdPASS) {
            vPrintString("Could not send to the queue.\r\n");
        }
    }
}

// Receiver task to receive data from the queue
static void vReceiverTask(void *pvParameters) {
    Data_t xReceivedStructure;
    BaseType_t xStatus;

    for (;;) {
        // Wait until the queue is full (all senders have sent data)
        while (uxQueueMessagesWaiting(xQueue) < 2) {
            vTaskDelay(pdMS_TO_TICKS(100));  // Wait for the queue to be filled
        }

        // Receive data from the queue
        xStatus = xQueueReceive(xQueue, &xReceivedStructure, 0);
        if (xStatus == pdPASS) {
            // Print the received value and the source of the value
            if (xReceivedStructure.eDataSource == eSender1) {
                vPrintStringAndNumber("From Sender 1 = ", xReceivedStructure.ucValue);
            } else {
                vPrintStringAndNumber("From Sender 2 = ", xReceivedStructure.ucValue);
            }
        } else {
            vPrintString("Could not receive from the queue.\r\n");
        }
    }
}

/*******************************************************************************
* Function Name: main
*********************************************************************************
* Summary:
* This is the main function for CPU. It initializes the hardware, creates tasks,
* and starts the scheduler.
*
* Parameters:
*  void
*
* Return:
*  int
*******************************************************************************/
int main(void) {
    cy_rslt_t result;

#if defined(CY_DEVICE_SECURE) && defined(CY_USING_HAL)
    cyhal_wdt_t wdt_obj;

    /* Clear watchdog timer so that it doesn't trigger a reset */
    result = cyhal_wdt_init(&wdt_obj, cyhal_wdt_get_max_timeout_ms());
    CY_ASSERT(CY_RSLT_SUCCESS == result);
    cyhal_wdt_free(&wdt_obj);
#endif

    /* Initialize the device and board peripherals */
    result = cybsp_init();

    /* Board init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS) {
        CY_ASSERT(0);
    }

    /* Enable global interrupts */
    /* Initialize UART for retargeted IO (so we can print to UART) */
    result = cy_retarget_io_init(CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX, CY_RETARGET_IO_BAUDRATE);
    if (result != CY_RSLT_SUCCESS) {
        CY_ASSERT(0);  // UART initialization failed, stop here
    }
    __enable_irq();

    xQueue = xQueueCreate(3, sizeof(Data_t));  // Create the queue with a size of 3
    if (xQueue != NULL) {
        // Create tasks for sender and receiver
        xTaskCreate(vSenderTask, "Sender1", 1000, (void *)&(xStructsToSend[0]), 2, NULL);
        xTaskCreate(vSenderTask, "Sender2", 1000, (void *)&(xStructsToSend[1]), 2, NULL);
        xTaskCreate(vReceiverTask, "Receiver", 1000, NULL, 1, NULL);

        vTaskStartScheduler();  // Start the FreeRTOS scheduler
    } else {
        /* The queue could not be created. */
        vPrintString("Queue creation failed.\r\n");
    }

    for(;;);
}


/*******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for the Empty Application Example
*              for ModusToolbox.
*
* Related Document: See README.md
*
*
*******************************************************************************/
/*******************************************************************************
* Header Files
*******************************************************************************/
#include "cybsp.h"
#include "cyhal.h"
#include "cy_retarget_io.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

/******************************************************************************
* Macros
*******************************************************************************/


/*******************************************************************************
* Global Variables
*******************************************************************************/
static QueueHandle_t xQueue1 = NULL;
static QueueHandle_t xQueue2 = NULL;
static QueueSetHandle_t xQueueSet = NULL;
/*******************************************************************************
* Function Prototypes
*******************************************************************************/

void vPrintString(const char *pcString);
void TaskSendDataToQueue1(void *pvParameters);
void TaskSendDataToQueue2(void *pvParameters);
void TaskReceiveDataToQueue(void *pvParameters);
/*******************************************************************************
* Function Definitions
*******************************************************************************/
// * Function Name: vPrintString
// * Description: This function sends a string to UART using retargeted IO
// */
void vPrintString(const char *pcString)
{
    printf("%s", pcString);  // Print the string to UART (Retarget IO)
}

// function to print and number
void vPrintStringAndNumber(const char *pcString, volatile uint32_t ul)
{
    printf("%s", pcString);  // Print the string to UART (Retarget IO)
    printf(" %ld\n", ul);  // Print the string to UART (Retarget IO)
}

// function to send data to the queue
void TaskSendDataToQueue1(void *pvParameters) {
    BaseType_t xStatus;
    const TickType_t xBlockTime = pdMS_TO_TICKS(100);
    const char * const pcMessage = "Message from vSenderTask1\r\n";

    while (1) {
        vTaskDelay(xBlockTime);
        xStatus = xQueueSendToBack(xQueue1, &pcMessage, 0);
        if (xStatus != pdPASS) {
            vPrintString("Could not send to Queue 1.\r\n");
        }
    }
}

// function to send data to the queue
void TaskSendDataToQueue2(void *pvParameters) {
    BaseType_t xStatus;
    const TickType_t xBlockTime = pdMS_TO_TICKS(100);
    const char * const pcMessage = "Message from vSenderTask2\r\n";

    while (1) {
        vTaskDelay(xBlockTime);
        xStatus = xQueueSendToBack(xQueue2, &pcMessage, 0);
        if (xStatus != pdPASS) {
            vPrintString("Could not send to Queue 2.\r\n");
        }
    }
}

// function to receive data from queue
void TaskReceiveDataToQueue(void *pvParameters) {
    QueueHandle_t xQueueThatContainsData;
    char *pcReceivedString;

    for (;;) {
        // Wait for an item to be available in the queue set
        xQueueThatContainsData = (QueueHandle_t)xQueueSelectFromSet(xQueueSet, portMAX_DELAY);

        if (xQueueThatContainsData != NULL) {
            // Receive the data from the selected queue
            xQueueReceive(xQueueThatContainsData, &pcReceivedString, 0);
            vPrintString(pcReceivedString);  // Print received message
        }
    }
}

/*******************************************************************************
* Function Name: main
*********************************************************************************
* Summary:
* This is the main function for CPU. It...
*    1.
*    2.
*
* Parameters:
*  void
*
* Return:
*  int
*
*******************************************************************************/
int main(void) {
    cy_rslt_t result;

#if defined (CY_DEVICE_SECURE) && defined (CY_USING_HAL)
    cyhal_wdt_t wdt_obj;

    /* Clear watchdog timer so that it doesn't trigger a reset */
    result = cyhal_wdt_init(&wdt_obj, cyhal_wdt_get_max_timeout_ms());
    CY_ASSERT(CY_RSLT_SUCCESS == result);
    cyhal_wdt_free(&wdt_obj);
#endif

    /* Initialize the device and board peripherals */
    result = cybsp_init();

    /* Board init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS) {
        CY_ASSERT(0);
    }

    /* Enable global interrupts */
    /* Initialize UART for retargeted IO (so we can print to UART) */
    result = cy_retarget_io_init(CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX, CY_RETARGET_IO_BAUDRATE);
    if (result != CY_RSLT_SUCCESS) {
        CY_ASSERT(0);  // UART initialization failed, stop here
    }
    __enable_irq();

    // Create queues with a capacity of 1 message each
    xQueue1 = xQueueCreate(1, sizeof(char *));
    xQueue2 = xQueueCreate(1, sizeof(char *));

    // Create the queue set with space for 2 queues
    xQueueSet = xQueueCreateSet(2);  // Ensure the argument is 2 here
    xQueueAddToSet(xQueue1, xQueueSet);
    xQueueAddToSet(xQueue2, xQueueSet);

    // Create the tasks
    xTaskCreate(TaskSendDataToQueue1, "Task1", 1000, NULL, 1, NULL);
    xTaskCreate(TaskSendDataToQueue2, "Task2", 1000, NULL, 1, NULL);
    xTaskCreate(TaskReceiveDataToQueue, "Task3", 1000, NULL, 2, NULL);

    // Start the scheduler so the tasks begin executing
    vTaskStartScheduler();

    // Infinite loop (should never be reached)
    for (;;) { }
}

